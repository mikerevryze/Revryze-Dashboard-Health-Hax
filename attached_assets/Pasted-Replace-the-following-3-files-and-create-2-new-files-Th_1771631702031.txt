Replace the following 3 files and create 2 new files. The current SQL queries in routes.ts reference tables called deals and ads that don't exist in our Snowflake. Our actual table is GHL_OPPORTUNITIES in the REVRYZE.RAW schema. Here are the exact file contents:

1. Replace shared/schema.ts with:

import { z } from "zod";

export const metricsSchema = z.object({
  total_deals: z.number(),
  open_deals: z.number(),
  won_deals: z.number(),
  lost_deals: z.number(),
  total_value: z.number(),
});

export type Metrics = z.infer<typeof metricsSchema>;

export const funnelStageSchema = z.object({
  pipeline_name: z.string(),
  stage_name: z.string(),
  count: z.number(),
  total_value: z.number(),
});

export type FunnelStage = z.infer<typeof funnelStageSchema>;

export const recentDealSchema = z.object({
  name: z.string(),
  stage_name: z.string(),
  status: z.string(),
  value: z.number(),
  updated_at: z.string().nullable(),
});

export type RecentDeal = z.infer<typeof recentDealSchema>;

export const dashboardSchema = z.object({
  metrics: metricsSchema,
  funnel: z.array(funnelStageSchema),
  recent: z.array(recentDealSchema),
});

export type DashboardData = z.infer<typeof dashboardSchema>;

2. Replace server/routes.ts with:

import type { Express } from "express";
import { type Server } from "http";
import { executeQuery } from "./snowflake";
import { log } from "./logger";

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  app.get("/api/metrics", async (_req, res) => {
    try {
      const rows = await executeQuery<{
        TOTAL_DEALS: number;
        WON_DEALS: number;
        LOST_DEALS: number;
        OPEN_DEALS: number;
        TOTAL_VALUE: number;
      }>(`
        SELECT
          COUNT(*)                                           AS TOTAL_DEALS,
          SUM(CASE WHEN STATUS = 'won' THEN 1 ELSE 0 END)   AS WON_DEALS,
          SUM(CASE WHEN STATUS = 'lost' THEN 1 ELSE 0 END)  AS LOST_DEALS,
          SUM(CASE WHEN STATUS = 'open' THEN 1 ELSE 0 END)  AS OPEN_DEALS,
          COALESCE(SUM(MONETARY_VALUE), 0)                   AS TOTAL_VALUE
        FROM GHL_OPPORTUNITIES
      `);

      const row = rows[0];
      res.json({
        total_deals: Number(row?.TOTAL_DEALS) || 0,
        won_deals: Number(row?.WON_DEALS) || 0,
        lost_deals: Number(row?.LOST_DEALS) || 0,
        open_deals: Number(row?.OPEN_DEALS) || 0,
        total_value: Number(row?.TOTAL_VALUE) || 0,
      });
    } catch (err: any) {
      log(`Metrics endpoint error: ${err.message}`, "api");
      res.status(500).json({ message: "Failed to fetch metrics from Snowflake" });
    }
  });

  app.get("/api/funnel", async (_req, res) => {
    try {
      const rows = await executeQuery<{
        PIPELINE_NAME: string;
        PIPELINE_STAGE_NAME: string;
        OPP_COUNT: number;
        TOTAL_VALUE: number;
      }>(`
        SELECT
          PIPELINE_NAME,
          PIPELINE_STAGE_NAME,
          COUNT(*)                        AS OPP_COUNT,
          COALESCE(SUM(MONETARY_VALUE),0) AS TOTAL_VALUE
        FROM GHL_OPPORTUNITIES
        WHERE STATUS != 'lost'
        GROUP BY PIPELINE_NAME, PIPELINE_STAGE_NAME
        ORDER BY PIPELINE_NAME, OPP_COUNT DESC
      `);

      res.json(
        rows.map((r) => ({
          pipeline_name: r.PIPELINE_NAME || "Unknown",
          stage_name: r.PIPELINE_STAGE_NAME || "Unknown",
          count: Number(r.OPP_COUNT) || 0,
          total_value: Number(r.TOTAL_VALUE) || 0,
        }))
      );
    } catch (err: any) {
      log(`Funnel endpoint error: ${err.message}`, "api");
      res.status(500).json({ message: "Failed to fetch funnel data" });
    }
  });

  app.get("/api/recent", async (_req, res) => {
    try {
      const rows = await executeQuery<{
        NAME: string;
        PIPELINE_STAGE_NAME: string;
        STATUS: string;
        MONETARY_VALUE: number;
        UPDATED_AT_TS: string | null;
      }>(`
        SELECT NAME, PIPELINE_STAGE_NAME, STATUS, MONETARY_VALUE, UPDATED_AT_TS
        FROM GHL_OPPORTUNITIES
        ORDER BY UPDATED_AT_TS DESC
        LIMIT 10
      `);

      res.json(
        rows.map((r) => ({
          name: r.NAME || "Unnamed",
          stage_name: r.PIPELINE_STAGE_NAME || "Unknown",
          status: r.STATUS || "unknown",
          value: Number(r.MONETARY_VALUE) || 0,
          updated_at: r.UPDATED_AT_TS ?? null,
        }))
      );
    } catch (err: any) {
      log(`Recent deals endpoint error: ${err.message}`, "api");
      res.status(500).json({ message: "Failed to fetch recent deals" });
    }
  });

  return httpServer;
}

3. Replace client/src/pages/dashboard.tsx with:

import { useQuery } from "@tanstack/react-query";
import {
  Trophy,
  DollarSign,
  Users,
  XCircle,
  TrendingUp,
  Activity,
} from "lucide-react";
import { MetricCard } from "@/components/MetricCard";
import { FunnelChart } from "@/components/FunnelChart";
import { RecentDeals } from "@/components/RecentDeals";
import { Skeleton } from "@/components/ui/skeleton";
import { Card } from "@/components/ui/card";
import type { Metrics, FunnelStage, RecentDeal } from "@shared/schema";

function formatCurrency(value: number): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value);
}

function LoadingSkeleton() {
  return (
    <div className="mx-auto w-full max-w-6xl px-4 py-8 sm:px-6 lg:px-8">
      <div className="mb-8 flex items-center gap-3">
        <Skeleton className="h-8 w-8 rounded-md" />
        <Skeleton className="h-7 w-48" />
      </div>
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
        {Array.from({ length: 6 }).map((_, i) => (
          <Card key={i} className="border-card-border bg-card p-5">
            <div className="flex items-start justify-between gap-3">
              <div className="flex-1 space-y-3">
                <Skeleton className="h-3 w-24" />
                <Skeleton className="h-8 w-32" />
              </div>
              <Skeleton className="h-10 w-10 rounded-md" />
            </div>
          </Card>
        ))}
      </div>
    </div>
  );
}

function ErrorState({ message }: { message: string }) {
  return (
    <div className="mx-auto w-full max-w-6xl px-4 py-8 sm:px-6 lg:px-8">
      <Card className="border-destructive/30 bg-card p-8 text-center">
        <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-destructive/10">
          <XCircle className="h-6 w-6 text-destructive" />
        </div>
        <h3 className="text-lg font-semibold text-foreground">
          Unable to load metrics
        </h3>
        <p className="mt-2 text-sm text-muted-foreground" data-testid="text-error-message">
          {message}
        </p>
      </Card>
    </div>
  );
}

export default function Dashboard() {
  const { data: metrics, isLoading: metricsLoading, error: metricsError } = useQuery<Metrics>({
    queryKey: ["/api/metrics"],
    refetchInterval: 60000,
  });

  const { data: funnel, isLoading: funnelLoading } = useQuery<FunnelStage[]>({
    queryKey: ["/api/funnel"],
    refetchInterval: 60000,
  });

  const { data: recent, isLoading: recentLoading } = useQuery<RecentDeal[]>({
    queryKey: ["/api/recent"],
    refetchInterval: 60000,
  });

  if (metricsLoading) return <LoadingSkeleton />;
  if (metricsError) return <ErrorState message={(metricsError as Error).message} />;
  if (!metrics) return <ErrorState message="No data available" />;

  const conversionRate =
    metrics.total_deals > 0
      ? ((metrics.won_deals / metrics.total_deals) * 100).toFixed(1)
      : "0.0";

  return (
    <div className="mx-auto w-full max-w-6xl px-4 py-8 sm:px-6 lg:px-8">
      <div className="mb-8">
        <h1 className="text-2xl font-bold tracking-tight text-foreground sm:text-3xl">
          Performance Dashboard
        </h1>
        <p className="mt-1 text-sm text-muted-foreground">
          GHL Pipeline Stats &middot; Live from Snowflake
        </p>
      </div>

      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
        <MetricCard
          title="Total Deals"
          value={metrics.total_deals.toLocaleString()}
          icon={Users}
          subtitle="All opportunities in pipeline"
        />
        <MetricCard
          title="Open Deals"
          value={metrics.open_deals.toLocaleString()}
          icon={Activity}
          subtitle="Currently active deals"
        />
        <MetricCard
          title="Won Deals"
          value={metrics.won_deals.toLocaleString()}
          icon={Trophy}
          subtitle="Closed won"
        />
        <MetricCard
          title="Lost Deals"
          value={metrics.lost_deals.toLocaleString()}
          icon={XCircle}
          subtitle="Closed lost"
        />
        <MetricCard
          title="Conversion Rate"
          value={`${conversionRate}%`}
          icon={TrendingUp}
          subtitle="Won / Total deals"
        />
        <MetricCard
          title="Total Value"
          value={formatCurrency(metrics.total_value)}
          icon={DollarSign}
          subtitle="Sum of all deal values"
        />
      </div>

      <div className="mt-8">
        {funnelLoading ? (
          <Card className="border-card-border bg-card p-6">
            <Skeleton className="mb-4 h-6 w-40" />
            <div className="space-y-3">
              {Array.from({ length: 5 }).map((_, i) => (
                <Skeleton key={i} className="h-8 w-full" />
              ))}
            </div>
          </Card>
        ) : funnel && funnel.length > 0 ? (
          <FunnelChart funnel={funnel} />
        ) : null}
      </div>

      <div className="mt-8">
        {recentLoading ? (
          <Card className="border-card-border bg-card p-6">
            <Skeleton className="mb-4 h-6 w-40" />
            <div className="space-y-2">
              {Array.from({ length: 5 }).map((_, i) => (
                <Skeleton key={i} className="h-10 w-full" />
              ))}
            </div>
          </Card>
        ) : recent && recent.length > 0 ? (
          <RecentDeals deals={recent} />
        ) : null}
      </div>
    </div>
  );
}

4. Create NEW file client/src/components/FunnelChart.tsx:

import { Card } from "@/components/ui/card";
import type { FunnelStage } from "@shared/schema";

interface FunnelChartProps {
  funnel: FunnelStage[];
}

export function FunnelChart({ funnel }: FunnelChartProps) {
  const maxCount = Math.max(...funnel.map((s) => s.count));

  return (
    <Card className="border-card-border bg-card p-6">
      <h2 className="mb-1 text-lg font-bold text-foreground">Pipeline Funnel</h2>
      <p className="mb-5 text-xs text-muted-foreground">
        Active deals by stage (excludes lost)
      </p>
      <div className="space-y-3">
        {funnel.map((stage, i) => (
          <div key={`${stage.pipeline_name}-${stage.stage_name}-${i}`}>
            <div className="mb-1 flex items-center justify-between text-sm">
              <span className="font-medium text-foreground">{stage.stage_name}</span>
              <span className="text-muted-foreground">
                {stage.count} deal{stage.count !== 1 ? "s" : ""}
              </span>
            </div>
            <div className="h-3 w-full overflow-hidden rounded-full bg-muted">
              <div
                className="h-3 rounded-full bg-[#10E29C] transition-all"
                style={{ width: `${(stage.count / maxCount) * 100}%` }}
              />
            </div>
          </div>
        ))}
      </div>
    </Card>
  );
}

5. Create NEW file client/src/components/RecentDeals.tsx:

import { Card } from "@/components/ui/card";
import type { RecentDeal } from "@shared/schema";

interface RecentDealsProps {
  deals: RecentDeal[];
}

const statusStyles: Record<string, string> = {
  open: "bg-yellow-500/20 text-yellow-400",
  won: "bg-green-500/20 text-green-400",
  lost: "bg-red-500/20 text-red-400",
  abandoned: "bg-gray-500/20 text-gray-400",
};

export function RecentDeals({ deals }: RecentDealsProps) {
  return (
    <Card className="border-card-border bg-card p-6">
      <h2 className="mb-1 text-lg font-bold text-foreground">Recent Activity</h2>
      <p className="mb-5 text-xs text-muted-foreground">Last 10 updated deals</p>
      <div className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b border-border text-left text-xs font-medium uppercase tracking-wider text-muted-foreground">
              <th className="pb-3">Name</th>
              <th className="pb-3">Stage</th>
              <th className="pb-3">Status</th>
              <th className="pb-3 text-right">Value</th>
              <th className="pb-3 text-right">Updated</th>
            </tr>
          </thead>
          <tbody>
            {deals.map((deal, i) => (
              <tr
                key={i}
                className="border-b border-border/50 transition-colors hover:bg-muted/30"
              >
                <td className="py-3 font-medium text-foreground">{deal.name}</td>
                <td className="py-3 text-muted-foreground">{deal.stage_name}</td>
                <td className="py-3">
                  <span
                    className={`inline-block rounded-full px-2 py-0.5 text-xs font-medium capitalize ${
                      statusStyles[deal.status] || "bg-muted text-muted-foreground"
                    }`}
                  >
                    {deal.status}
                  </span>
                </td>
                <td className="py-3 text-right text-muted-foreground">
                  ${(deal.value ?? 0).toLocaleString()}
                </td>
                <td className="py-3 text-right text-muted-foreground">
                  {deal.updated_at
                    ? new Date(deal.updated_at).toLocaleDateString()
                    : "â€”"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </Card>
  );
}

Do NOT change any other files. Keep server/snowflake.ts, server/index.ts, client/src/App.tsx, client/src/components/MetricCard.tsx, and all UI components exactly as they are. You can remove the GoalCalculator import from dashboard.tsx since it's no longer used there.